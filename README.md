[![Nuget](https://img.shields.io/nuget/v/Byteology.TypedHttpClients?style=for-the-badge)](https://www.nuget.org/packages/Byteology.TypedHttpClients/)
[![Code Coverage](https://img.shields.io/sonar/coverage/Byteology_typed-http-clients/master?color=%2310a910&server=https%3A%2F%2Fsonarcloud.io&style=for-the-badge)](https://sonarcloud.io/dashboard?id=Byteology_typed-http-clients)

[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=Byteology_typed-http-clients&metric=security_rating)](https://sonarcloud.io/dashboard?id=Byteology_typed-http-clients) 
[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=Byteology_typed-http-clients&metric=reliability_rating)](https://sonarcloud.io/dashboard?id=Byteology_typed-http-clients)
[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=Byteology_typed-http-clients&metric=sqale_rating)](https://sonarcloud.io/dashboard?id=Byteology_typed-http-clients)

# Byteology's Typed HTTP Clients

Usually when consuming an HTTP service, you will want to use a [typed HTTP client](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#implement-your-typed-client-classes-that-use-the-injected-and-configured-httpclient). There are two approaches on how to write them:

You can generate it using an existing [OpenAPI](https://www.openapis.org/) documentation and your favorite tool that generates the actual code. Unfortunately, not all services provide an OpenAPI documentation and even if they did, the generated code is not always exactly what you need. Maybe there are [arrays in the query string](https://medium.com/raml-api/arrays-in-query-params-33189628fa68) that need to be parsed differently or maybe there is some other inconstancy that forces you to make changes to the generated code and persist them after regeneration. Additionally, many of the generation tools don’t use any boilerplate code so you’ll have to change every single method call which defeats the purpose of the auto-generation. Another reason to not use auto-generated HTTP clients is that usually they will generate code for the whole service and maybe you want just a tiny part of it. This includes both methods and resources.

Another way that lets you have more control over the client is to just write it manually. The problem with this is that the process is tedious at best and error-prone at least. To avoid this we've created an extensible typed HTTP client base class that provided a lean contract of the service can execute HTTP requests and process their responses.

## Defining the servce contract

Before being able to consume a service you have to define its contract or at least the parts of it you'll be using. The contract is an interface with async methods that are decorated with the `HttpEndpointAttribute`. The typed HTTP client will create an implementation of the contract on its initialization during runtime. The implementation details will be inferred from the methods' signatures and their attributes. Bellow is an example of a service contract. You have to manually create the interface but the resources' types can be either manually created or auto-generated by a tool when applicable.

```c#
public class Book
{
  public Guid Id { get; set; }
  public string Name { get; set; }
  public string Author { get; set; }
  public DateTime PublicationDate { get; set; }
}
```
```c#
public interface ILibraryService
{
  [HttpEndpoint("GET", "/books/{id}")]
  Task<Book> GetBookAsync(string id);
  
  [HttpEndpoint("GET", "/books")]
  Task<IEnumerable<Book>> GetBooksByAuthorAsync(string author);
  
  [HttpEndpoint("POST", "/books")]
  Task<Book> AddBookAsync([HttpBody] Book book);
  
  [HttpEndpoint("DELETE", "/books/{id}")]
  Task DeleteBookAsync(string id);
}
```

## Supported Clients

## Extending with your own typed clients
